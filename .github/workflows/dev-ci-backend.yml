name: CI - Build Backend Services

on:
  workflow_dispatch:
  push:
    branches:
      - dev

env:
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
  DOCKER_HUB_REPO_PREFIX: mantrasandbox/
  REPO_LOCATION: services/backend/
  # Set concurrency level (adjust based on your runner capacity)
  CONCURRENCY: 4

jobs:
  build-backend:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            /${{ env.REPO_LOCATION }}
          sparse-checkout-cone-mode: false
          skip-checks: true

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '21'
          cache: 'maven'

      - name: Cache Maven dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.m2/repository
            */target/**
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Verify checkout
        run: |
          ls -la
          cd services/backend
          ls -la

      - name: Find and build all Maven projects
        run: |
          find ${{ env.REPO_LOCATION }} -name pom.xml | while read pom; do
          echo "Building project in $(dirname $pom)..."
          mvn -B package --file "$pom" -Dmaven.test.skip=true -Dmaven.repo.local=$HOME/.m2/repository
          done

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          driver-opts: |
            image=moby/buildkit:master
          buildkitd-config: |
            [worker.oci]
              enabled = true
              max-parallelism = ${{ env.CONCURRENCY }}

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ env.DOCKER_TOKEN }}

      - name: Build and push Docker images
        run: |
          set -euo pipefail
          
          # Get list of services with both pom.xml and Dockerfile
          SERVICES=$(find ${{ env.REPO_LOCATION }} -name pom.xml -exec dirname {} \; | xargs -n1 basename)
          echo "Services to build: $SERVICES"
          
          if [ -z "$SERVICES" ]; then
            echo "::error::No services found to build"
            exit 1
          fi
          
          # Function to build a single service
          build_service() {
            local service_name=$1
            local service_dir="${{ env.REPO_LOCATION }}$service_name"
            local jar_file=$(find "$service_dir/target" -name "*.jar" ! -name "*original*" | head -n 1)
          
            if [ ! -f "$jar_file" ]; then
              echo "::error::No jar file found for $service_name in $service_dir/target/"
              return 1
            fi
          
            if [ ! -f "$service_dir/Dockerfile" ]; then
              echo "::error::No Dockerfile found for $service_name in $service_dir/"
              return 1
            fi
          
            echo "::group::Building Docker image for $service_name"
            docker buildx build \
              --push \
              --tag "${{ env.DOCKER_HUB_REPO_PREFIX }}$service_name:latest" \
              --tag "${{ env.DOCKER_HUB_REPO_PREFIX }}$service_name:$GIT_SHA" \
              --build-arg JAR_FILE=$(basename "$jar_file") \
              --file "$service_dir/Dockerfile" \
              "$service_dir"
            echo "::endgroup::"
          }
          
          export -f build_service
          
          # Run builds in parallel with error collection
          echo "$SERVICES" | xargs -P ${{ env.CONCURRENCY }} -I {} bash -c 'build_service "$@" || exit 255' _ {}
          
          # Check for failures (exit code 255 from above)
          if [ $? -eq 255 ]; then
            echo "::error::One or more builds failed"
            exit 1
          fi